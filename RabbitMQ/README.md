# Rabbit Mq 学习总结

## 1.mq概述

​	RabbitMQ 是一个基于 ***AMQP*** 协议实现的企业级消息系统 ，它是采用 Erlang 语言实现的 AMQP(Advanced Message Queued Protocol)的消息中间件，最初起源于金融系统，用在分布式系统存储转发消息，目前广泛应用于各类系统用于***解耦、削峰*** 。

### 1.1内部结构图 

#### 1.2图内基本概念

- ##### Message：具体的消息，包含消息头（即附属的配置信息）和消息体（即消息的实体内容），由发布者，将消息推送到 Exchange，由消费者从 Queue 中获取

- ##### publisher：消息生产者，负责将消息发布到交换器(Exchange) 。

- ##### Exchange：交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列 

- ##### Binding：绑定，用于给 Exchange 和 Queue 建立关系，从而决定将这个交换器中的哪些消息，发送到对应的 Queue 

- #####  Queue：消息队列，用来保存消息直到发送给消费者 ，它是消息的容器，也是消息的终点 ，一个消息可投入一个或多个队列 ，消息一直在队列里面，等待消费者连接到这个队列将其取走 。

- #####  Connection：连接，内部持有一些 channel，用于和 queue 打交道 。

- ##### Channel：信道（通道），MQ 与外部打交道都是通过 Channel 来的，发布消息、订阅队列还是接收消息，这些动作都是通过 Channel 完成； 简单来说就是消息通过 Channel 塞进队列或者流出队列 

- ##### Consumer：消费者，从消息队列中获取消息的主体 。

- ##### Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。 

## 2.特点

- 可靠性：通过支持消息持久化，支持事务，支持消费和传输的 ack 等来确保可靠性

- 路由机制：支持主流的订阅消费模式，如广播，订阅，headers 匹配等

- 扩展性：多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。

- 高可用性：队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队仍然可用。

- 多种协议：RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP，MQTT 等多种消息中间件协议。

- 多语言客户端：RabbitMQ 几乎支持所有常用语言，比如 Jav a、Python、Ruby、PHP、C#、JavaScript 等。

- 管理界面：RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。

- 插件机制：RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。

  

## 3.各种消息中间件性能的比较：

TPS比较 一ZeroMq 最好，RabbitMq 次之， ActiveMq 最差。

持久化消息比较—zeroMq不支持，activeMq和rabbitMq都支持。持久化消息主要是指：MQ down或者MQ所在的服务器down了，消息不会丢失的机制。

可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统、社区—RabbitMq最好，ActiveMq次之，ZeroMq最差。

高并发—从实现语言来看，RabbitMQ最高，原因是它的实现语言是天生具备高并发高可用的erlang语言。

综上所述：RabbitMQ的性能相对来说更好更全面，是消息中间件的首选。

### 3.1**为什么要选择RabbitMQ** ？

- 基于AMQP协议  高并发 高性能  ， 高可用，强大的社区支持，以及很多公司都在使用，支持插件，支持多语言

## 4.**生产者和消费者** 

生产者创建消息，消费者接受消息，一个应用程序既可以作为生产者发送消息也可以作为一个消费者接受消息，再此之前，必须建立一条信道*channel* 

### 4.1工作模式

#### 	4.1.1PTP(point to point)**点对点** 

Produce生产消息体，使用匿名交换机(exchange=’’’)，与消费者绑定相同的队列(队列名称一样)，生产者生产一条消息，往MQ里扔一条，消费者消费一条数据。此模式生产者与消费者是一对一存在的 

#### 	4.1.2发布/订阅模式 	

此模式不再使用匿名交换机，而是自定义的交换机。交换机类型分为四种：直连交换机、扇形交换机、主题交换机、头交换机。此图为扇形交换机的例子，即发消息到所有与之绑定的队列。  生产者生产消息->交换机->绑定的队列->消费者 

## 5.消息持久化

##### 5.1Exchange需要持久化。

##### 5.2Queue需要持久化。

##### 5.3Message需要持久化。

##### 5.4消息持久化原理

​	RabbitMQ创建的队列和交换器在默认情况下无法幸免于服务器重启，重启服务后，队列和交换机联通里面的消息就会消失  因为交换机和列队的默认durable=false,设置成true,就会避免重启或者宕机后队列和交换器的消失，但是消息还是会丢失  所以当把交换器和队列的durable设置成true还是不够的，还需要持久化消息，在消息发布之前，通过把它的投递模式delivery mode选项设置成2来吧消息标记成持久化，只有这2个条件同时满足才可以保证消息不会丢失 

​	Virtual host:属于哪个Virtual host。

​	Name：名字，同一个Virtual host里面的Name不能重复。

​	Durability： 是否持久化，Durable：持久化。Transient：不持久化。

​	Auto delete：当最后一个绑定（队列或者exchange）被unbind之后，该exchange自动被删除。

​	Internal： 是否是内部专用exchange，是的话，就意味着我们不能往该exchange里面发消息。

​	Arguments： 参数，是AMQP协议留给AMQP实现做扩展使用的。
 alternate_exchange配置的时候，exchange根据路由路由不到对应的队列的时候，这时候消息被路由到指定的alternate_exchange的value值配置的exchange上。

### 5.6消息确认 

在消费比较耗时的消息时，如果消费者执行到一半时挂掉，这时MQ是不知道的，并且此条消费被认为已经消费掉了，会造成消息丢失的情况。加入消息确认后，消息被拿走后MQ不会立即删除掉本条消息。消费者在消费消息成功后会向MQ发送一个ack确认标识表示已经消费完成，此时MQ将本条消息删除。如果消费者在消费过程中挂掉，消费超时后MQ会认为这个消费者联系不上了，会自动将本条消息发送给其它消费者。 



## 6.**交换机和绑定**

Exchange在RabbitMQ消息中间件中的作用：
  服务器发送消息不会直接发送到队列中（Queue），而是直接发送给交换机（Exchange），然后根据确定的规则，RabbitMQ将会决定消息该投递到哪个队列。这些规则称为路由键（routing   key），队列通过路由键绑定到交换机上。消息发送到服务器端（broker），消息也有自己的路由键（也可以是空），RabbitMQ也会将消息和消息指定发送的交换机的绑定（binding，就是队列和交互机的根据路由键映射的关系）的路由键进行匹配。如果匹配的话，就会将消息投递到相应的队列。协议中定义了不同的交换机，4种类型的交换机

- **fanout** 扇形交换机 交换机会给所有绑定该交换机的队列通信。 
- **direct **直连交换机 交换机会拿着消费的routing_key与其所有直接满足绑定名的绑定队列通信 。 
- **topic**主题交换机 （常用）交换机会拿着消费的routing_key给所有满足匹配的绑定名的绑定队列通信 
- **headers**

Fanout Exchange：直接将消息转发到所有binding的对应queue中，这种exchange在路由转发的时候，忽略Routing key。

Direct Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行比较，如果相等，则发送到该Binding对应的Queue中。

Topic Exchange：将消息中的Routing key与该Exchange关联的所有Binding中的Routing key进行对比，如果匹配上了，则发送到该Binding对应的Queue中。

Headers Exchange：将消息中的headers与该Exchange相关联的所有Binging中的参数进行匹配，如果匹配上了，则发送到该Binding对应的Queue中。

